<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset="utf-8" />
		<meta name="author" content="CLÃ‰MENT Cyril" />
		<meta name="description" content="Swift, Apple's new programming language for iOS and OS was introduced by Apple at WWDC 2014. It was build on the best of C and Objective-C and represent the future of Apple software development. Here is my note from Apple's iBook, The Swift Programming Language." />
		<meta name="robots" content="Index,Follow" />
		<meta name="viewport" content="initial-scale=1.0" />

		<title>Swift - clmntcrl</title>

		<link rel="stylesheet" href="/css/style.css">
	</head><body>
		<section id="w" class="post">
			<nav><a href="/">clmntcrl.io</a> / <a href="/blog/">Blog</a> / <a href="/blog/swift/">Swift</a></nav>
			<section>
<header><h1><a href="/blog/swift/">Swift</a></h1><time pubdate="2014-06-06 00:00:00 +0100">Jun 06 2014</time></header>
<p>Swift, Apple's new programming language for iOS and OS was introduced by Apple at WWDC 2014. It was build on the best of C and Objective-C and represent the future of Apple software development.</p>
<p>Here is my note about Apple's iBook, <a href="https://itunes.apple.com/fr/book/swift-programming-language/id881256329?mt=11" target="_blank">The Swift Programming Language</a>.</p>
<p>First:</p>
<pre><code>println("Hello, world")</code></pre>
<p>Forget the <code>;</code> and read the following for a swift tour.</p>
<hr />
<p><strong>Updated</strong> (Jul 15 2014) to adopt new Swift syntax after its first <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/RevisionHistory.html" target="_blank">revision</a>.</p>
<hr />
<h2 id="simple-value"><a href="#simple-value">Simple value</a></h2>
<pre><code>let constant = 1
var variable = 1</code></pre>
<p>Type of a variable (or constant) is infered by the compiler when providing a value. Type can be specified like this:</p>
<pre><code>let explicitDouble: Double = 2</code></pre>
<p>Value are never implicitly converted to another type.</p>
<code><pre>var lineLabel = "Line " + String(3)

// Simpler way to include value in strings

lineLabel = "Line \(5)"</code></pre>
<p>Arrays and dictionaries use brackets (<code>[]</code>).</p>
<pre><code>var array = [
	"an element",
	"another element"
]
array += "last element"

var dictionary = [
	"a key": "an element",
	"another key": "another value"
]
dictionary["a key"] = "I'am an element"

// Empty  array or dictionary

let emptyArray = [String]()
let emptyDictionary = [String: String]()</code></pre>
<h2 id="control-flow"><a href="#control-flow">Control flow</a></h2>
<p>Parentheses around the condition or loop variable are optional. Braces around the body are required.</p>
<p>Condition in an <code>if</code> statement must be a boolean expression. <code>?</code> can be used after the type of a value to mark it as optional.</p>
<pre><code>var optionalInt: Int?

if !optionalInt {
	optionalInt = 8
}</pre></code>
<p>Switches support any kind of data and wide variety of comparison operations. <code>break</code> are implicit.</p>
<pre><code>let day = "Friday"

switch day {
case "Monday":
    "Not my favorite day"
case "Thursday", "Wednesday", "Tuesday":
    "When is the weekend ?"
case let d where d.uppercaseString == "FRIDAY":
    "Weekend is coming soon..."
case"Saturday", "Sunday":
    "ðŸ˜Ž"
default:
    "Not a day"
}</pre></code>
<h2 id="functions"><a href="#functions">Functions</a></h2>
<pre><code>func addOneTo(number: Int) -> Int {
    return number + 1
}</pre></code>
<p>Function can return multiple values using <code>tuples</code>.</p>
<pre><code>func prices() -> (Double, Double, Double) {
    return (0.0, 0.99, 1.29)
}</pre></code>
<p>Function can take a variable number of arguments.</p>
<pre><code>func sumOf(numbers: Int...) -> Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}</pre></code>
<p>Function can be nested.</p>
<p>Functions accept functions as arguments and return value.</p>
<pre><code>func getMyFunc(function: (Int, Int) -> Int) -> ((Int, Int) -> Int) {
    return function
}</pre></code>
<h2 id="closures"><a href="#closures">Closures</a></h2>
<pre><code>var numbers = [13, 21, 34, 55]

numbers.map({
    (number: Int) -> Int in
    return number * 2
})
numbers.map({ number in number * 2 })
numbers.map({ $0 * 2 })
numbers.map() { $0 * 2 }
numbers.map { $0 * 2 }

// [26, 42, 68, 110]</pre></code>
<h2 id="objects-and-classes"><a href="#objects-and-classes">Objects and Classes</a></h2>
<p>Methods that override the superclass's implementation are mark with <code>override</code>.</p>
<p>Methods can specify a second name for parameters, which is used inside the method.</p>
<pre><code>class Counter {
    var count: Int

    init() {
        count = 0
    }
    func incrementBy(amount: Int, numberOfTimes times: Int) {
        count += amount * times
    }
}

var counter = Counter()
counter.incrementBy(2, numberOfTimes:1_024)</code></pre>
<h2 id="enumerations-and-structures"><a href="#enumerations-and-structures">Enumerations and structures</a></h2>
<p>Enumerations can have methods associated with them.</p>
<p>An instance of an enumeration member can have values associated with the instance:</p>
<pre><code>enum ServerResponse {
    case Result(String, String)
    case Error(String)
}
ServerResponse.Result("200", "OK")</code></pre>
<p>Structures support many of the same behaviors as classes, including methods and initializers. Structures are always passed by copy while classes are passed by reference.</p>
<pre><code>struct Point {
    var x: Int
    var y: Int

    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    func description() -> String {
        return "Point: { x: \(x), y: \(y) }"
    }
}

let p = Point(x:0, y:0)</pre></code>
<h2 id="protocols-and-extensions"><a href="#protocols-and-extensions">Protocols and Extensions</a></h2>
<p>Classes, enumerations, and structs can adopt protocols.</p>
<pre><code>protocol PrintProtocol {
    var description: String { get }

    mutating func print()
}

class PrintableClass: PrintProtocol {
    var description: String = "Printable class"

    func print() {
        println(description)
    }
}</code></pre>
<p>Enumerations and structures need <code>mutating</code> keyword to mark a method that modifies the structure.</p>
<pre><code>struct PrintableStruct: PrintProtocol {
    var description: String = "Printable struct"

    mutating func print() {
        println(description)
    }
}</pre></code>
<p>Extensions are used to add functionality to an existing type, such as methods and computed properties. Extensions can be used to add protocol conformance to a type.</p>
<pre><code>extension Double {
    func modulus() -> Double {
        return abs(self)
    }
}</code></pre>
<h2 id="generics"><a href="#generics">Generics</a></h2>
<p>Functions, methods, classes, enumerations and structures can be generic.</p>
<pre><code>func repeat&lt;T&gt;(item: T, times: Int) -> [T] {
    var result = [T]()
    for i in 0 ..&lt; times {
        result += item
    }
    return result
}
repeat("knock", 2)</code></pre>
<p>Type can require to implement protocol, to be the same as an other type or to have a particular superclass.</p>
<pre><code>func commonElements &lt;T, U where T: Sequence, U: Sequence,
    T.GeneratorType.Element: Equatable,
    T.GeneratorType.Element == U.GeneratorType.Element&gt;
    (lhs: T, rhs: U) -&gt; [T.GeneratorType.Element] {
        var result = Array&lt;T.GeneratorType.Element&gt;()
        for lhsItem in lhs {
            for rhsItem in rhs {
                if lhsItem == rhsItem {
                    result += rhsItem
                }
            }
        }
        return result
}
commonElements([1, 2, 3, 4], [2, 4, 6])</code></pre>
<hr />
<p>It's a quick tour of Swift and there is so much to write...</p>
			</section>
		</section>
	</body>
</html>